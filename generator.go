package ez

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"reflect"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/getkin/kin-openapi/openapi3gen"
	"sigs.k8s.io/yaml"
)

// DocMetadata contains additional metadata for API documentation
type DocMetadata struct {
	Title       string
	Description string
	Version     string
	Contact     *openapi3.Contact
	License     *openapi3.License
	Servers     []*openapi3.Server
	Tags        []*openapi3.Tag
}

// DefaultDocMetadata returns default documentation metadata
func DefaultDocMetadata() *DocMetadata {
	return &DocMetadata{
		Title:       "EZ API",
		Description: "API documentation generated by EZ framework",
		Version:     "1.0.0",
		Contact: &openapi3.Contact{
			Name: "EZ Framework",
			URL:  "https://github.com/biancarosa/ez",
		},
		License: &openapi3.License{
			Name: "MIT",
			URL:  "https://opensource.org/licenses/MIT",
		},
		Servers: []*openapi3.Server{
			{
				URL:         "http://localhost:8080",
				Description: "Local development server",
			},
		},
		Tags: []*openapi3.Tag{
			{
				Name:        "default",
				Description: "Default API endpoints",
			},
		},
	}
}

type DocsGenerator[T any, U any] struct {
	server   *EZServer[T, U]
	docs     OpenAPIDocs
	metadata *DocMetadata
}

type OpenAPIDocs struct {
	OpenAPI    string              `json:"openapi" yaml:"openapi"`
	Info       openapi3.Info       `json:"info" yaml:"info"`
	Servers    []*openapi3.Server  `json:"servers,omitempty" yaml:"servers,omitempty"`
	Components openapi3.Components `json:"components,omitempty" yaml:"components,omitempty"`
	Paths      openapi3.Paths      `json:"paths" yaml:"paths"`
	Tags       []*openapi3.Tag     `json:"tags,omitempty" yaml:"tags,omitempty"`
}

// NewDocsGenerator creates a new documentation generator with default metadata
func NewDocsGenerator[T any, U any](server *EZServer[T, U]) *DocsGenerator[T, U] {
	return &DocsGenerator[T, U]{
		server:   server,
		metadata: DefaultDocMetadata(),
	}
}

// WithMetadata sets custom metadata for the documentation
func (g *DocsGenerator[T, U]) WithMetadata(metadata *DocMetadata) *DocsGenerator[T, U] {
	g.metadata = metadata
	return g
}

func (g *DocsGenerator[T, U]) GenerateDocs() error {
	fmt.Println("Generating docs...")

	// Initialize OpenAPI document with metadata
	g.docs = OpenAPIDocs{
		OpenAPI: "3.0.0",
		Info: openapi3.Info{
			Title:       g.metadata.Title,
			Description: g.metadata.Description,
			Version:     g.metadata.Version,
			Contact:     g.metadata.Contact,
			License:     g.metadata.License,
		},
		Servers:    g.metadata.Servers,
		Components: openapi3.NewComponents(),
		Paths:      make(map[string]*openapi3.PathItem),
		Tags:       g.metadata.Tags,
	}

	// Initialize components
	g.docs.Components.Schemas = make(map[string]*openapi3.SchemaRef)
	g.docs.Components.Responses = make(map[string]*openapi3.ResponseRef)
	g.docs.Components.Parameters = make(map[string]*openapi3.ParameterRef)
	g.docs.Components.Examples = make(map[string]*openapi3.ExampleRef)
	g.docs.Components.RequestBodies = make(map[string]*openapi3.RequestBodyRef)
	g.docs.Components.Headers = make(map[string]*openapi3.HeaderRef)
	g.docs.Components.SecuritySchemes = make(map[string]*openapi3.SecuritySchemeRef)
	g.docs.Components.Links = make(map[string]*openapi3.LinkRef)
	g.docs.Components.Callbacks = make(map[string]*openapi3.CallbackRef)

	// Process routes
	for _, route := range g.server.GetRoutes() {
		if err := g.GenerateDocsForRoute(route); err != nil {
			return fmt.Errorf("failed to generate docs for route %s: %w", route.Pattern, err)
		}
	}

	fmt.Println("Creating files...")
	if err := g.GenerateOpenAPIFiles(); err != nil {
		return fmt.Errorf("failed to generate OpenAPI files: %w", err)
	}

	fmt.Println("Docs generated!")
	return nil
}

func (g *DocsGenerator[T, U]) GenerateDocsForRoute(route Route[T, U]) error {
	var reqSchema *openapi3.SchemaRef
	var resSchema *openapi3.SchemaRef
	var err error

	// Check if request type is not zero value
	reqValue := reflect.ValueOf(route.Request)
	if reqValue.IsValid() && !reqValue.IsZero() {
		reqSchema, err = openapi3gen.NewSchemaRefForValue(route.Request, nil)
		if err != nil {
			return fmt.Errorf("failed to generate request schema: %w", err)
		}
		t := reflect.TypeOf(route.Request)
		schemaName := getTypeName(t)
		g.docs.Components.Schemas[schemaName] = reqSchema
	}

	// Check if response type is not zero value
	resValue := reflect.ValueOf(route.Response)
	if resValue.IsValid() && !resValue.IsZero() {
		resSchema, err = openapi3gen.NewSchemaRefForValue(route.Response, nil)
		if err != nil {
			return fmt.Errorf("failed to generate response schema: %w", err)
		}
		t := reflect.TypeOf(route.Response)
		schemaName := getTypeName(t)
		g.docs.Components.Schemas[schemaName] = resSchema
	}

	// Initialize path item if not exists
	if _, exists := g.docs.Paths[route.Pattern]; !exists {
		g.docs.Paths[route.Pattern] = &openapi3.PathItem{}
	}

	// Process each HTTP method
	for _, method := range route.Method {
		operation := &openapi3.Operation{
			OperationID: fmt.Sprintf("%s-%s", strings.TrimPrefix(route.Pattern, "/"), method),
			Summary:     fmt.Sprintf("%s %s", method, route.Pattern),
			Tags:        []string{getTagFromPath(route.Pattern)},
			Parameters:  []*openapi3.ParameterRef{},
			Responses:   make(map[string]*openapi3.ResponseRef),
		}

		// Add request body if exists
		if reqValue.IsValid() && !reqValue.IsZero() {
			operation.RequestBody = &openapi3.RequestBodyRef{
				Value: &openapi3.RequestBody{
					Required: true,
					Content: map[string]*openapi3.MediaType{
						"application/json": {
							Schema: reqSchema,
						},
					},
				},
			}
		}

		// Add response if exists
		if resValue.IsValid() && !resValue.IsZero() {
			operation.Responses["200"] = &openapi3.ResponseRef{
				Value: &openapi3.Response{
					Description: ptr("Successful response"),
					Content: map[string]*openapi3.MediaType{
						"application/json": {
							Schema: resSchema,
						},
					},
				},
			}
		}

		// Add operation to path item based on method
		switch method {
		case http.MethodGet:
			g.docs.Paths[route.Pattern].Get = operation
		case http.MethodPost:
			g.docs.Paths[route.Pattern].Post = operation
		case http.MethodPut:
			g.docs.Paths[route.Pattern].Put = operation
		case http.MethodDelete:
			g.docs.Paths[route.Pattern].Delete = operation
		case http.MethodPatch:
			g.docs.Paths[route.Pattern].Patch = operation
		}
	}

	return nil
}

// getTypeName returns a clean type name for OpenAPI schema
func getTypeName(t reflect.Type) string {
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	return t.Name()
}

// getTagFromPath extracts a tag from the path
func getTagFromPath(path string) string {
	parts := strings.Split(strings.TrimPrefix(path, "/"), "/")
	if len(parts) > 0 {
		return parts[0]
	}
	return "default"
}

// ptr returns a pointer to the given value
func ptr[T any](v T) *T {
	return &v
}

func (g *DocsGenerator[T, U]) GenerateOpenAPIFiles() error {
	// Generate JSON
	jsonB, err := json.MarshalIndent(g.docs, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal JSON: %w", err)
	}

	// Generate YAML
	schema, err := yaml.JSONToYAML(jsonB)
	if err != nil {
		return fmt.Errorf("failed to convert JSON to YAML: %w", err)
	}

	// Write files
	if err := os.WriteFile("./openapi.json", jsonB, 0666); err != nil {
		return fmt.Errorf("failed to write JSON file: %w", err)
	}

	if err := os.WriteFile("./openapi.yaml", schema, 0666); err != nil {
		return fmt.Errorf("failed to write YAML file: %w", err)
	}

	return nil
}
